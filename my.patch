diff --git a/README.md b/README.md
index c6b3969..fd3e53b 100644
--- a/README.md
+++ b/README.md
@@ -748,6 +748,40 @@ Both these settings (`strictOptionParsing` and `strictArrayExtraction`) can be e
 val formats: Formats = DefaultFormats.strict
 ```
 
+Json 3.6 expands the `strictOptionParsing` behavior to throw a MappingException even when `extractOpt` is called on a missing optional attribute.  This behavior might not be desirable if you have a large code base that was using `extractOpt` prior to Json 3.6.  If you prefer to maintain the pre-3.6 `extractOpt` behavior, you can specify the format option `strictOptionParsingPre36`
+
+```scala
+val formats: Formats = new DefaultFormats {
+  override val strictOptionParsingPre36: Boolean = true
+}
+```
+
+Note the following examples:
+
+### Pre-3.6 behavior
+
+```scala
+val formats: Formats = new DefaultFormats {
+  override val strictOptionParsingPre36: Boolean = true
+}
+case class SerializationSpec(someInt: Int, someString: Option[String])
+val json = parse("""{ "someInt": 123 }""")
+// someString is None
+val someString = (json \ "someString").extractOpt[String]
+```
+
+### Post-3.6 behavior
+
+```scala
+val formats: Formats = new DefaultFormats {
+  override val strictOptionParsing: Boolean = true
+}
+case class SerializationSpec(someInt: Int, someString: Option[String])
+val json = parse("""{ "someInt": 123 }""")
+// throws MappingException.
+val someString = (json \ "someString").extractOpt[String]
+```
+
 Serialization
 =============
 
@@ -792,7 +826,7 @@ Serialization supports:
 * Recursive types
 * Serialization of fields of a class (see below)
 * Custom serializer functions for types that are not supported (see below)
- 
+
 If the class contains camel-case fields (i.e: firstLetterLowercaseAndNextWordsCapitalized) but you want to produce a json string with snake casing (i.e., separated_by_underscores), you can use the `snakizeKeys` method:
 
 ```scala
@@ -801,7 +835,7 @@ ser: String = {"firstName":"Mary"}
 
 scala> compact(render(parse(ser).snakizeKeys))
 res0: String = {"first_name":"Mary"}
-``` 
+```
 
 Serializing polymorphic Lists
 -----------------------------
diff --git a/core/src/main/scala/org/json4s/Extraction.scala b/core/src/main/scala/org/json4s/Extraction.scala
index c745d43..c15bf70 100644
--- a/core/src/main/scala/org/json4s/Extraction.scala
+++ b/core/src/main/scala/org/json4s/Extraction.scala
@@ -366,7 +366,7 @@ object Extraction {
         Right(extract(json, scalaType.typeArgs(1)))
       })).getOrElse(fail("Expected value but got " + json))
     } else if (scalaType.isOption) {
-      customOrElse(scalaType, json)(v => (if(formats.strictOptionParsing) v.toSome else v.toOption) flatMap (j => Option(extract(j, scalaType.typeArgs.head))))
+      customOrElse(scalaType, json)(v => (if(formats.strictOptionParsing || formats.strictOptionParsingPre36) v.toSome else v.toOption) flatMap (j => Option(extract(j, scalaType.typeArgs.head))))
     } else if (scalaType.isMap) {
       customOrElse(scalaType, json)({
         _ match {
@@ -564,7 +564,7 @@ object Extraction {
         } catch {
           case e @ MappingException(msg, _) =>
             if (descr.isOptional &&
-                (!formats.strictOptionParsing || extract(json, ScalaType[Null](implicitly)) == null))
+                (!(formats.strictOptionParsing || formats.strictOptionParsingPre36) || extract(json, ScalaType[Null](implicitly)) == null))
               defv(None)
             else fail("No usable value for " + descr.name + "\n" + msg, e)
         }
diff --git a/core/src/main/scala/org/json4s/Formats.scala b/core/src/main/scala/org/json4s/Formats.scala
index 4797c59..aaf87a9 100644
--- a/core/src/main/scala/org/json4s/Formats.scala
+++ b/core/src/main/scala/org/json4s/Formats.scala
@@ -81,6 +81,7 @@ trait Formats extends Serializable { self: Formats =>
   def companions: List[(Class[_], AnyRef)] = Nil
   def allowNull: Boolean = true
   def strictOptionParsing: Boolean = false
+  def strictOptionParsingPre36: Boolean = false
   def strictArrayExtraction: Boolean = false
   def alwaysEscapeUnicode: Boolean = false
 
@@ -110,6 +111,7 @@ trait Formats extends Serializable { self: Formats =>
                     wCompanions: List[(Class[_], AnyRef)] = self.companions,
                     wAllowNull: Boolean = self.allowNull,
                     wStrictOptionParsing: Boolean = self.strictOptionParsing,
+                    wStrictOptionParsingPre36: Boolean = self.strictOptionParsingPre36,
                     wStrictArrayExtraction: Boolean = self.strictArrayExtraction,
                     wAlwaysEscapeUnicode: Boolean = self.alwaysEscapeUnicode,
                     wEmptyValueStrategy: EmptyValueStrategy = self.emptyValueStrategy): Formats =
@@ -127,6 +129,7 @@ trait Formats extends Serializable { self: Formats =>
       override def companions: List[(Class[_], AnyRef)] = wCompanions
       override def allowNull: Boolean = wAllowNull
       override def strictOptionParsing: Boolean = wStrictOptionParsing
+      override def strictOptionParsingPre36: Boolean = wStrictOptionParsingPre36
       override def strictArrayExtraction: Boolean = wStrictArrayExtraction
       override def alwaysEscapeUnicode: Boolean = wAlwaysEscapeUnicode
       override def emptyValueStrategy: EmptyValueStrategy = wEmptyValueStrategy
diff --git a/tests/src/test/scala/org/json4s/StrictOptionParsingModePre36Spec.scala b/tests/src/test/scala/org/json4s/StrictOptionParsingModePre36Spec.scala
new file mode 100644
index 0000000..ad04322
--- /dev/null
+++ b/tests/src/test/scala/org/json4s/StrictOptionParsingModePre36Spec.scala
@@ -0,0 +1,60 @@
+package org.json4s
+
+import org.specs2.mutable.Specification
+import org.json4s.native.Document
+
+object NativeStrictOptionParsingPre36Spec extends StrictOptionParsingModePre36Spec[Document]("Native") with native.JsonMethods
+object JacksonStrictOptionParsingPre36Spec extends StrictOptionParsingModePre36Spec[JValue]("Jackson") with jackson.JsonMethods
+
+final case class Pre36Spec(someInt: Int, someString: Option[String], someEnum: Option[EnumSpec])
+final case class EnumSpec(someString: String)
+
+class EnumSpecSerializer extends CustomSerializer[EnumSpec](
+  implicit formats =>
+    ({
+      case JString(s) =>
+        s match {
+        case "MI" | "mi" => EnumSpec(s)
+        case _ => throw new MappingException(s"value ${s} not found")
+      }
+    }, {
+      case x: EnumSpec =>
+        JString(x.toString)
+    })
+)
+
+abstract class StrictOptionParsingModePre36Spec[T](mod: String) extends Specification with JsonMethods[T] {
+
+  implicit lazy val formats: Formats = new DefaultFormats { override val strictOptionParsingPre36: Boolean = true } + new EnumSpecSerializer()
+
+  val complexTypeSpec1 = """{ "someInt": 123, "someString": "Foo", "someEnum": "MI" }"""
+  val complexTypeSpec3 = """{ "someInt": 123, "someString": "Foo", "someEnum": "XX" }"""
+  val complexTypeSpec2 = """{ "someInt": 123 }"""
+
+  (mod + " case class with a complex type") should {
+    "succeed with some values" in {
+      val model = parse(complexTypeSpec1).extract[Pre36Spec]
+      model.someInt must_== 123
+      model.someString must_== Some("Foo")
+      model.someEnum must_== Some(EnumSpec("MI"))
+    }
+    "succeed with missing values" in {
+      val model = parse(complexTypeSpec2).extract[Pre36Spec]
+      model.someInt must_== 123
+      model.someString must_== None
+      model.someEnum must_== None
+    }
+    "fail expectedly with invalid values" in {
+      parse(complexTypeSpec3).extract[Pre36Spec] must throwA[MappingException]
+    }
+    "behave expectedly with invalid values scenario 2" in {
+      val json = parse(complexTypeSpec3)
+      (json \ "someString").extractOpt[String] must_== Some("Foo")
+      (json \ "someEnum").extractOpt[EnumSpec] must_== None
+    }
+    "succeed as expected with missing values" in {
+      val json = parse(complexTypeSpec2)
+      (json \ "someEnum").extractOpt[EnumSpec] must_== None
+    }
+  }
+}
